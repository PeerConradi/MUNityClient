@*
    Ich denke es wäre ganz cool, wenn hier ein Menüband Unten für die Steuerung ist.
    Dieses muss dann recht klein gehalten werden und soll beim auswählen Overlays/Popups generieren in
    welchen die Details sind.

    Das Menüband könnte auch ein wenig Transparent sein und sobald der Benutzer mit der Maus drüber fährt wird die Transparenz komplett
    ausgeblendet.

    Punkte sind:
    - Allgemeine Einstellungen (immer sichtbar)
    - Redeliste (sichtbar für den Vorsitz)
    - Anwesenheit (sichtbar für den Vorsitz)
    - Abstimmung (sichtbar für den Vorsitz)

    zudem QuickControls für die Redeliste:
    - Redner pausieren/fortsetzen bzw. Frage pausieren/fortsetzen
    Ist abhängig vom Context der Redeliste.
*@

@inject Services.SimulationService simulationService;

<!-- Grey with black text -->
<nav class="navbar navbar-expand-sm bg-primary navbar-dark nav-bottom w-100" style="opacity: 0.75;">
    <ul class="navbar-nav">
        <li class="nav-item">
            <a class="nav-link" @onclick="() => _selectedTab = (_selectedTab == TabPages.GeneralControls) ? TabPages.None : TabPages.GeneralControls">Allgemeine Funktionen</a>
        </li>
        <li class="nav-item">
            <a class="nav-link" @onclick="() => _selectedTab = (_selectedTab == TabPages.ListOfSpeakers) ? TabPages.None : TabPages.ListOfSpeakers">Redeliste</a>
        </li>
    <li class="nav-item">
        <a class="nav-link" @onclick="() => { _selectedTab = (_selectedTab == TabPages.Voting) ? TabPages.None : TabPages.Voting; _hasNewVotes = false; }">
            Abstimmung @if (_hasNewVotes)
            {
                <span class="badge badge-danger">Neu</span>
            }
        </a>
        
    </li>
        <!--
    <li class="nav-item">
        <a class="nav-link">Anwesenheit</a>
    </li>
    -->
        @if (Role != null && Role.RoleType == MUNity.Schema.Simulation.SimulationEnums.RoleTypes.Chairman)
        {
            <li class="nav-item">
                <a class="nav-link" @onclick="() => _selectedTab = (_selectedTab == TabPages.Petitions) ? TabPages.None : TabPages.Petitions">
                    Anträge @if (_petitions != null && _petitions.Any())
                    {
                        <span class="badge bg-danger">@_petitions.Count</span>
                    }
                </a>
                
            </li>
        }

    </ul>
</nav>

@if (_selectedTab == TabPages.GeneralControls)
{
    <div class="card floating-card shadow-2">

        <SimulationControlsGeneral Me="@Me"
                                   Role="@Role"
                                   SimulationId="@SimulationId"
                                   SpeakerlistId="@SpeakerlistId"></SimulationControlsGeneral>


    </div>
}

@if (_selectedTab == TabPages.ListOfSpeakers)
{
    <div class="card floating-card shadow-2">
        @* Von der Sache her könnte an dieser Stelle auch die Beiden Buttons für auf die Redelisten und auf die FuK erscheinen. *@
        @if (!string.IsNullOrEmpty(SpeakerlistId) && SpeakerlistId != "_loading_")
        {
            @if (Role != null && Role.RoleType == MUNity.Schema.Simulation.SimulationEnums.RoleTypes.Chairman)
            {
                <MUNityClient.Pages.LoS.ListOfSpeakerEditor Id="@SpeakerlistId" IsOnline="@true"></MUNityClient.Pages.LoS.ListOfSpeakerEditor>
            }
            else
            {
                @* TODO: Buttons um auf die Redeliste oder FuK zu kommen an diese Stelle verschieben *@
            }
        }
        else if (SpeakerlistId == "_loading_")
        {
            <p>Redeliste wird geladen</p>
        }
        else
        {
            <p>Keine Redeliste</p>
        }
    </div>
}

@if (_selectedTab == TabPages.Petitions)
{
    <div class="card floating-card shadow-2">
        <div class="list-group">
            @* Anträge können aktuell bearbeitet werden. Das wird darüber eingeleitet, dass diese angenommen werden
        Nachdem der Antrag in dieser Angenommen liste gelandet ist, wird er (wenn bearbeitet) einfach gelöscht. *@
            @foreach (var activePetition in _currentPetitions)
            {
                <a class="list-group-item list-group-item-action" @onclick="() => AcceptPetition(activePetition)">
                    <div class="d-flex w-100 justify-content-between">

                        <h5 class="mb-1">@GetPetitionDisplayName(activePetition)</h5>
                        <small class="text-muted">@activePetition.PetitionDate.ToShortTimeString()</small>
                    </div>
                    <p class="mb-1">
                        @if (activePetition.PetitionType == MUNity.Schema.Simulation.Petition.PetitionTypes.GOAbschlussRedeliste)
                        {
                            <span>GO: Abschluss oder Wiedereröffnung der Redeliste</span>
                        }
                        else
                        {
                            <span>@activePetition.PetitionType.ToString()</span>
                        }
                    </p>
                </a>
            }

            @foreach (var petition in _petitions)
            {
                <a class="list-group-item list-group-item-action" @onclick="() => AcceptPetition(petition)">
                    <div class="d-flex w-100 justify-content-between">

                        <h5 class="mb-1">@GetPetitionDisplayName(petition)</h5>
                        <small class="text-muted">@petition.PetitionDate.ToShortTimeString()</small>
                    </div>
                    <p class="mb-1">
                        @if (petition.PetitionType == MUNity.Schema.Simulation.Petition.PetitionTypes.GOAbschlussRedeliste)
                        {
                            <span>GO: Abschluss oder Wiedereröffnung der Redeliste</span>
                        }
                        else
                        {
                            <span>@petition.PetitionType.ToString()</span>
                        }
                    </p>
                </a>
            }
        </div>
    </div>
}

@if (_selectedTab == TabPages.Voting)
{

    @if (_lastCreatedVote == null && Role != null && Role.RoleType == MUNity.Schema.Simulation.SimulationEnums.RoleTypes.Chairman)
    {
        <div class="card floating-card shadow-2">
            <CreateVoteComponent SimulationId="@SimulationId"></CreateVoteComponent>
        </div>
    }
    else if (_lastCreatedVote != null && _lastCreatedVote.AllowedUsers.Contains(Me.SimulationUserId))
    {
        <div class="card floating-card shadow-2">
            <div class="row">
                <div class="col-12">
                    <p>@_lastCreatedVote.Text</p>
                </div>
                <div class="col-12">
                    <button class="btn btn-success btn-block" @onclick="VotePro">Dafür</button>
                </div>
                <div class="col-12">
                    <button class="btn btn-danger btn-block" @onclick="VoteCon">Dagegen</button>
                </div>
                @if (_lastCreatedVote.AllowAbstention)
                {
                    <div class="col-12">
                        <button class="btn btn-primary btn-block" @onclick="VoteAbstention">Enthaltung</button>
                    </div>
                }
            </div>
        </div>
    }
}


@code {
    private enum TabPages
    {
        None,
        GeneralControls,
        ListOfSpeakers,
        Voting,
        Presents,
        Petitions
    }

    [Parameter]
    public MUNity.Schema.Simulation.SimulationRoleItem Role { get; set; }

    [Parameter]
    public string SpeakerlistId { get; set; }

    [Parameter]
    public int SimulationId { get; set; }

    [Parameter]
    public MUNity.Schema.Simulation.IUserItem Me { get; set; }

    [Parameter]
    public Services.SocketHandlers.SimulationSocketHandler Socket { get; set; }

    [Parameter]
    public IEnumerable<MUNity.Schema.Simulation.IUserItem> Users { get; set; }

    [Parameter]
    public IEnumerable<MUNity.Schema.Simulation.SimulationRoleItem> Roles { get; set; }

    private TabPages _selectedTab = TabPages.None;

    private bool _hasNewPetition { get; set; } = false;

    private bool _hasNewVotes { get; set; } = false;

    private MUNity.Schema.Simulation.CreatedVoteModel _lastCreatedVote { get; set; } = null;

    private string GetPetitionDisplayName(MUNity.Schema.Simulation.Petition petition)
    {
        if (Users == null) return "Unbekannt";
        var user = Users.FirstOrDefault(n => n.SimulationUserId == petition.PetitionUserId);
        if (user == null) return "Unbekannt";
        if (user.RoleId == -2 || Roles == null) return user.DisplayName ?? "Unbekannt";
        var role = Roles.FirstOrDefault(n => n.SimulationRoleId == user.RoleId);
        if (role != null) return role.Name;
        return "Unbekannt";
    }


    // Fürs erste halten wir die Liste der Anträge in diesem Menü, es ist vielleicht sinnvoll
    // diese im Runner selbst zu halten und an die anderen zu erben ~Peer
    private List<MUNity.Schema.Simulation.Petition> _petitions { get; set; }

    private List<MUNity.Schema.Simulation.Petition> _currentPetitions { get; set; }

    protected override void OnInitialized()
    {
        _petitions = new List<MUNity.Schema.Simulation.Petition>();
        _currentPetitions = new List<MUNity.Schema.Simulation.Petition>();
        if (Socket != null)
        {
            Socket.UserPetition += OnUserPetition;
            Socket.UserPetitionAccpted += OnUserPetitionAccepted;
            Socket.UserPetitionDeleted += OnUserPetitionDeleted;
            Socket.VoteCreated += VoteCreated;
        }
        base.OnInitialized();
    }

    private async void AcceptPetition(MUNity.Schema.Simulation.Petition petition)
    {
        await simulationService.AcceptPetition(petition);
    }

    private void OnUserPetition(MUNity.Schema.Simulation.Petition petition)
    {
        _petitions.RemoveAll(n => n.PetitionUserId == petition.PetitionUserId);
        _petitions.Add(petition);
        this.StateHasChanged();
    }

    private void OnUserPetitionAccepted(MUNity.Schema.Simulation.Petition petition)
    {
        _petitions.RemoveAll(n => n.PetitionId == petition.PetitionId);
        _currentPetitions.Add(petition);
        this.StateHasChanged();
    }

    private void OnUserPetitionDeleted(MUNity.Schema.Simulation.Petition petition)
    {
        _petitions.RemoveAll(n => n.PetitionId == petition.PetitionId);
        _currentPetitions.RemoveAll(n => n.PetitionId == petition.PetitionId);
        this.StateHasChanged();
    }

    private void VoteCreated(object sender, MUNity.Schema.Simulation.CreatedVoteModel args)
    {
        _hasNewVotes = true;
        _lastCreatedVote = args;
        StateHasChanged();
    }

    private async Task VotePro()
    {
        if (_lastCreatedVote != null)
        {
            await this.simulationService.Vote(SimulationId, _lastCreatedVote.CreatedVoteModelId, 0);
            _lastCreatedVote = null;
            _hasNewVotes = false;
            _selectedTab = TabPages.None;
        }

    }

    private async Task VoteCon()
    {
        if (_lastCreatedVote != null)
        {
            await this.simulationService.Vote(SimulationId, _lastCreatedVote.CreatedVoteModelId, 1);
            _lastCreatedVote = null;
            _hasNewVotes = false;
            _selectedTab = TabPages.None;
        }

    }

    private async Task VoteAbstention()
    {
        if (_lastCreatedVote != null)
        {
            await this.simulationService.Vote(SimulationId, _lastCreatedVote.CreatedVoteModelId, 2);
            _lastCreatedVote = null;
            _hasNewVotes = false;
            _selectedTab = TabPages.None;
        }

    }
}

<style>
    .header-item {
        transition: .3s;
    }

        .header-item:not(.selected-tab):hover {
            background-color: #dedede;
        }

    .selected-tab {
        background-color: #1266F1;
        color: white;
    }

    .floating-card {
        position: fixed;
        top: auto;
        bottom: 70px;
        left: 10px;
        right: auto;
        z-index: 100;
    }

    .nav-bottom {
        position: fixed;
        top: auto;
        bottom: 0px;
        left: 0px;
        right: auto;
        z-index: 100;
    }
</style>

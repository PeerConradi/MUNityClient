@using MUNityClient.Models.ListOsSpeakers;
@using System.Timers;

@page "/los/edit/{id}"

@inject MUNityClient.Services.ListOfSpeakerService listOfSpeakerService;

@if (Speakerlist != null)
{
    <div class="row">
        <EditForm Model="@Settings" OnSubmit="SaveSettings">
            <div class="form-group">
                <label>Redzeit</label>
                <InputText @bind-Value="Settings.Speakertime" class="form-control" />
            </div>
            <div class="form-group">
                <label>Zeit für Fragen, Kurzbemerkdungen und Antwort</label>
                <InputText @bind-Value="Settings.Questiontime" class="form-control" />
            </div>
            
            <button class="btn btn-success" type="submit">Speichern</button>
        </EditForm>
    </div>
    <h3>Aktueller Redner</h3>

    @if (Speakerlist.CurrentSpeaker != null)
    {
        <h4>@Speakerlist.CurrentSpeaker.Name</h4>
        <h4>Verbleibende Redezeit</h4>
        @* Achtung derzeit wird einfach nur hoch gezählt wenn die Zeit übschritten wurde.
            Eine Zeitüebrschreibung lässt sich feststellen indem einfach auf:
            RemainingSpeakerTime.TotalSeconds < 0 geprüft wird.
            Für die an der Steuerung ist es sicher sinnvoll, wenn sie sehen um wie viel
            überzogen wurde. Auf der Teiliansicht muss aber an dieser Stelle "Bitte zum Ende kommen" stehen
            anstelle einer Zeit. Zudem soll die Textfarbe der Restzeit sich ändern, wenn RemainingSpeakerTime.TotalSeconds < 10 ist.*@
        <h4>@Speakerlist.RemainingSpeakerTime.ToString(@"mm\:ss")</h4>
    }
    else
    {
        <h4>Niemand :(</h4>
    }

    <h3>Warteliste Redebeitrag</h3>

    <ul>
        @foreach (var speaker in Speakerlist.Speakers)
        {
            <li>@speaker.Name</li>
        }
    </ul>

    <hr />

    <h3>Aktuelle Frage/Kurzbemerkung</h3>
    @if (Speakerlist.CurrentQuestion != null)
    {
        <h4>@Speakerlist.CurrentQuestion.Name</h4>
        <h4>Verbleibende Zeit</h4>
        <h4>@Speakerlist.RemainingQuestionTime.ToString(@"mm\:ss")</h4>
    }
    else
    {
        <h3>Niemand</h3>
    }

    <h3>Warteliste Fragen und Kurzbemerkungen</h3>

    <ul>
        @foreach (var question in Speakerlist.Questions)
        {
            <li>@question.Name</li>
        }
    </ul>

    <hr />

    <button @onclick="() => Speakerlist.NextSpeaker()">Nächster Redner</button>
    @* Es ist sicherlich sinnvoll Redezeitstarten/Pausieren und Fortsetzen in einem zu vereinen.
        Redezeit Starten gibt dem Redner aktuell die Volle Redezeit und wäre somit immer ein Reset.
        Es ist natürlich möglich das "Nächster Redner" in eine eigene Funktion zu packen und dadurch zu schauen
        ob pausiert wurde oder nicht.
    *@
    <button @onclick="() => Speakerlist.StartSpeaker()">Redezeit starten</button>
    <button @onclick="() => Speakerlist.PauseSpeaker()">Redezeit/Frage und Kurzbemerkung pausieren</button>
    <button @onclick="() => Speakerlist.ResumeSpeaker()">Redebeitrag Fortsetzen</button>
    <EditForm Model="NewSpeaker">
        <div class="form-group">
            <label>Name</label>
            <InputText @bind-Value="NewSpeaker.Name" class="form-control" />
        </div>

    </EditForm>

    <button @onclick="() => AddToSpeakers()">Auf die Redeliste setzen</button>
    <button @onclick="() => AddToQuestions()">Auf Fragen und Kurzbemerkungen setzen</button>

}

@code {
    [Parameter]
    public string Id { get; set; }

    public ListOfSpeakers Speakerlist { get; set; }

    private class SpeakerToAdd
    {
        public string Iso { get; set; }

        public string Name { get; set; }
    }

    private class SpeakerlistSettings
    {
        public string Speakertime { get; set; }

        public string Questiontime { get; set; }

        public SpeakerlistSettings()
        {

        }

        public SpeakerlistSettings(ListOfSpeakers source)
        {
            Speakertime = source.SpeakerTime.ToString(@"mm\:ss");
            Questiontime = source.QuestionTime.ToString(@"mm\:ss");
        }
    }

    private SpeakerlistSettings Settings { get; set; }

    private SpeakerToAdd NewSpeaker = new SpeakerToAdd();

    private void SaveSettings()
    {
        var spekaerTime = Speakerlist.SpeakerTime;
        var questionTime = Speakerlist.QuestionTime;
        if (TimeSpan.TryParseExact(Settings.Speakertime, @"mm\:ss", null, out spekaerTime))
        {
            this.Speakerlist.SpeakerTime = spekaerTime;
        }
        else
        {
            // Die Eingabe der Redezeit ist ungültig!
        }

        if (TimeSpan.TryParseExact(Settings.Questiontime, @"mm\:ss", null, out questionTime))
        {
            this.Speakerlist.QuestionTime = questionTime;
        }
        else
        {
            // Die Eingegebene Zeit für Fragen und Kurzbemerkungen ist ungültig.
        }
    }

    private void TimerElapsed(object sender, ElapsedEventArgs args)
    {
        this.StateHasChanged();
    }

    private EventCallback AddToSpeakers()
    {
        this.Speakerlist.AddSpeaker(NewSpeaker.Name);
        NewSpeaker.Name = "";
        return EventCallback.Empty;
    }

    private EventCallback AddToQuestions()
    {
        this.Speakerlist.AddQuestion(NewSpeaker.Name);
        NewSpeaker.Name = "";
        return EventCallback.Empty;
    }

    protected override async Task OnInitializedAsync()
    {
        this.Speakerlist = await this.listOfSpeakerService.GetListOfSpeakers(this.Id);
        if (this.Speakerlist != null)
        {
            this.Settings = new SpeakerlistSettings(this.Speakerlist);

            // Wir bauen jetzt für den ersten Entwurf einen Timer, welcher
            // jede Sekunde neu Zeichnet. Der Grund dafür ist, dass die
            // Redeliste nicht selber mit einem Timer arbeitet sondern
            // Startzeiten mit der aktuellen Uhrzeit Synct und hierdurch
            // die Redezeiten berechnet.
            // Es ist theoretisch möglich sich von der Redeliste ein StateChanged Event geben zu lassen
            // dann kann der Timer pausiert werden, wenn ohnehin gerade niemand spricht, aber ich halte
            // eine aktualisierung der Ansicht (kein Serverping) nicht für zu viel. ~Peer
            var timer = new Timer(1000);
            timer.Elapsed += TimerElapsed;
            timer.Start();
            base.OnInitialized();
        }
    }
}
